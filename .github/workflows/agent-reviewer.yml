# üîé HiveMind Reviewer Agent
# PR code review
#
# Trigger: pull_request opened (Created by Coder implementation)
# Task: Inspect Code, Check Rules, Security Analysis

name: 'üîé Agent: Reviewer (Gemini)'

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  # ü¶Å Beast Mode: Push Trigger
  push:
    branches: ['**']

concurrency:
  group: reviewer-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

jobs:
  check-access:
    name: 'üõ°Ô∏è Check Access'
    runs-on: ubuntu-latest
    outputs:
      is_trusted: ${{ steps.check.outputs.is_trusted }}
    steps:
      - name: Verify Actor
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            const author = context.actor;
            const botWhitelist = ['google-labs-jules[bot]', 'dependabot[bot]', 'github-actions[bot]'];
            
            let isTrusted = false;
            
            // 1. Check Bot Whitelist
            if (botWhitelist.includes(author)) {
              isTrusted = true;
              console.log(`‚úÖ Bot ${author} is in the whitelist.`);
            } else {
              // 2. Pro-active API Check: Check collaborator permission level
              try {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  username: author
                });
                
                const level = permission.permission; // 'admin', 'write', 'read', 'none'
                console.log(`üîç Actor ${author} has permission level: ${level}`);
                
                if (['admin', 'write'].includes(level)) {
                  isTrusted = true;
                  console.log(`‚úÖ Actor ${author} is trusted via API (level: ${level})`);
                }
              } catch (e) {
                console.log(`‚ö†Ô∏è API Check failed or actor is not a collaborator: ${e.message}`);
                // Fallback: Check Repo Owner Handle
                if (author === context.repo.owner) {
                  isTrusted = true;
                  console.log(`‚úÖ Actor ${author} matches repo owner handle.`);
                }
              }
            }
            
            console.log(`Final Decision: is_trusted=${isTrusted}`);
            core.setOutput('is_trusted', String(isTrusted));

  review:
    name: 'üìù Code Review'
    needs: check-access
    if: needs.check-access.outputs.is_trusted == 'true'
    runs-on: ubuntu-latest
    
    permissions:
      contents: write # Required for commit comments
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install google-genai

      - name: Get Diff (Smart Switch)
        id: diff
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # üõ°Ô∏è Security: Map inputs to env vars to prevent command injection
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          EVENT_BEFORE: ${{ github.event.before }}
          EVENT_AFTER: ${{ github.event.after }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          if [ "$EVENT_NAME" == "pull_request" ]; then
            echo "üìã PR Mode detected."
            git fetch origin "$BASE_REF"
            git diff origin/"$BASE_REF"...HEAD -- . ':(exclude)package-lock.json' ':(exclude)yarn.lock' ':(exclude)*.min.js' ':(exclude)*.map' ':(exclude)dist/' ':(exclude)build/' > coder_changes.diff
          else
            echo "ü¶Å Beast Mode detected (Push)."
            # Get diff for Push: Current vs Previous commit
            if [ "$EVENT_BEFORE" == "0000000000000000000000000000000000000000" ]; then
               git diff HEAD^ HEAD > coder_changes.diff || git diff --cached > coder_changes.diff
            else
               git diff "$EVENT_BEFORE" "$EVENT_AFTER" -- . ':(exclude)package-lock.json' ':(exclude)dist/' > coder_changes.diff || git diff HEAD^ HEAD > coder_changes.diff
            fi
          fi
          
          ls -lh coder_changes.diff

      - name: Check Secrets
        id: check-secrets
        run: |
          if [ -n "${{ secrets.APP_ID }}" ]; then
            echo "has_app_id=true" >> $GITHUB_OUTPUT
          else
            echo "has_app_id=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate App Token (Optional - for custom branding)
        id: app-token
        if: steps.check-secrets.outputs.has_app_id == 'true'
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      # Use App token if available, otherwise fallback to GITHUB_TOKEN
      - name: Set Token
        id: set-token
        run: |
          if [ -n "${{ steps.app-token.outputs.token }}" ]; then
            echo "token=${{ steps.app-token.outputs.token }}" >> $GITHUB_OUTPUT
            echo "Using custom GitHub App token"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "Using default GITHUB_TOKEN"
          fi

      - name: Notify Review Started (PR Only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.set-token.outputs.token }}
          script: |
            // Find associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;
            
            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | üîÑ **WORKING** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [/] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n> üîé Reviewer: PR #${context.payload.pull_request.number} is being analyzed...\n> üîó [View PR](${context.payload.pull_request.html_url})`;

              // Search for existing status comment by marker
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50,
                sort: 'created',
                direction: 'desc'
              });
              const statusComment = comments.data.find(c => c.body.includes(marker));
              
              if (statusComment) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: statusComment.id,
                    body: body
                  });
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment update failed, creating new one.`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body
                  });
                }
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: body
                });
              }
            }

      - name: Read Swarm Rules
        id: rules
        run: |
          if [ -f .github/swarm_rules.md ]; then
            content=$(cat .github/swarm_rules.md)
            echo "RULES<<EOF" >> $GITHUB_ENV
            echo "$content" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "RULES=No specific rules found." >> $GITHUB_ENV
          fi

      - name: Fetch Issue Context (PR Only)
        id: issue-context
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.set-token.outputs.token }}
          script: |
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/);
            if (!issueMatch) {
              console.log('No issue number found in PR body.');
              core.exportVariable('ISSUE_TITLE', 'N/A');
              core.exportVariable('ISSUE_BODY', 'N/A');
              return;
            }

            const issueNumber = parseInt(issueMatch[1]);
            console.log(`Found issue number: ${issueNumber}`);

            try {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });

              console.log(`Successfully fetched issue title: ${issue.title}`);
              core.exportVariable('ISSUE_TITLE', issue.title);
              core.exportVariable('ISSUE_BODY', issue.body || 'No issue body provided.');
            } catch (error) {
              console.error(`Failed to fetch issue #${issueNumber}:`, error);
              core.exportVariable('ISSUE_TITLE', 'Error fetching title');
              core.exportVariable('ISSUE_BODY', `Could not fetch issue content: ${error.message}`);
            }

      - name: Run Gemini Review
        id: review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ env.ISSUE_TITLE }}
          ISSUE_BODY: ${{ env.ISSUE_BODY }}
        run: |
          # Run swarm_reviewer.py script
          # Script will read coder_changes.diff and create review_comment.md
          # It will also write approved=true/false to GITHUB_OUTPUT
          python .github/scripts/swarm_reviewer.py

      - name: Apply Auto-Labels
        if: steps.review.outputs.labels != '' && github.event_name == 'pull_request'
        env:
          GH_TOKEN: ${{ steps.set-token.outputs.token }}
          LABELS: ${{ steps.review.outputs.labels }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "üè∑Ô∏è Applying labels: $LABELS"
          # Loop through comma-separated labels and apply each one individually
          # This prevents the workflow from failing if a label doesn't exist
          IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
          for label in "${LABEL_ARRAY[@]}"; do
            label=$(echo "$label" | xargs) # Trim whitespace
            echo "  ‚Üí Trying to add label: '$label'"
            gh pr edit "$PR_NUMBER" --add-label "$label" 2>/dev/null || echo "    ‚ö†Ô∏è Label '$label' not found, skipping."
          done
          echo "‚úÖ Label application complete."

      - name: Post Review (PR Mode)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
        with:
          github-token: ${{ steps.set-token.outputs.token }}
          script: |
            const fs = require('fs');
            
            // Read review result
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read or script failed.';
            }

            // Verify approval from script output (from steps/env)
            // Using steps.review.outputs.approved

            // swarm_reviewer.py GITHUB_OUTPUT'a approved yazƒ±yor, bunu steps objesinden alacaƒüƒ±z.
            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ APPROVED' : '‚ùå REJECTED';
            
            // PR'a review yaz
            if (reviewText.length > 10) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  event: approved ? 'APPROVE' : 'REQUEST_CHANGES',
                  body: `## üîé Gemini Code Review

                  ${reviewText}

                  ---

                  **Verdict:** ${verdict}

                  ${approved ? '> This PR is ready to merge.' : '> Please fix the issues mentioned above.'}`
                });
                // Note: Jules is triggered via REST API in the self-correction loop below
            }
            
            // Update associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;
            
            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | ‚úÖ **COMPLETED** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [x] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n---\n\n**Verdict:** ${verdict}\n\nüîó [PR #${context.payload.pull_request.number}](${context.payload.pull_request.html_url})\n\n${approved ? '> ‚úÖ **Ready to Merge!** Review passed.' : '> ‚ö†Ô∏è **Changes Needed.** Please address the issues.'}`;

              // Search for existing status comment by marker
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50,
                sort: 'created',
                direction: 'desc'
              });
              const statusComment = comments.data.find(c => c.body.includes(marker));
              
              if (statusComment) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: statusComment.id,
                    body: body
                  });
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment update failed, creating new one.`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body
                  });
                }
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: body
                });
              }

      - name: Load Config
        id: config
        run: |
          if [ -f .github/config.json ]; then
            echo "MAX_RETRIES=$(jq -r .max_retries .github/config.json)" >> $GITHUB_OUTPUT
          else
            echo "MAX_RETRIES=5" >> $GITHUB_OUTPUT
          fi

      - name: Post Review (PR Mode)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          MAX_RETRIES: ${{ steps.config.outputs.MAX_RETRIES }}
        with:
          github-token: ${{ steps.set-token.outputs.token }}
          script: |
            const fs = require('fs');

            // Read review result
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read or script failed.';
            }

            // Verify approval from script output (from steps/env)
            // Using steps.review.outputs.approved

            // swarm_reviewer.py GITHUB_OUTPUT'a approved yazƒ±yor, bunu steps objesinden alacaƒüƒ±z.
            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ APPROVED' : '‚ùå REJECTED';

            // PR'a review yaz
            if (reviewText.length > 10) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  event: approved ? 'APPROVE' : 'REQUEST_CHANGES',
                  body: `## üîé Gemini Code Review

                  ${reviewText}

                  ---

                  **Verdict:** ${verdict}

                  ${approved ? '> This PR is ready to merge.' : '> Please fix the issues mentioned above.'}`
                });
                // Note: Jules is triggered via REST API in the self-correction loop below
            }

            // Update associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;

            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | ‚úÖ **COMPLETED** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [x] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n---\n\n**Verdict:** ${verdict}\n\nüîó [PR #${context.payload.pull_request.number}](${context.payload.pull_request.html_url})\n\n${approved ? '> ‚úÖ **Ready to Merge!** Review passed.' : '> ‚ö†Ô∏è **Changes Needed.** Please address the issues.'}`;

              // Search for existing status comment by marker
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50,
                sort: 'created',
                direction: 'desc'
              });
              const statusComment = comments.data.find(c => c.body.includes(marker));

              if (statusComment) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: statusComment.id,
                    body: body
                  });
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment update failed, creating new one.`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body
                  });
                }
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: body
                });
              }

              // üîÑ SELF-CORRECTION LOOP (Strictly within !approved)
              if (!approved) {
                console.log("Executing self-correction logic...");
                const MAX_RETRIES = parseInt(process.env.MAX_RETRIES) || 5;
                const prNumber = context.payload.pull_request.number;

                // Detailed logging for review text check
                if (!reviewText || reviewText.trim().length < 10) {
                  console.log('‚ùå Self-correction skipped: Review text is too short or empty.');
                  return;
                }

                // Find Session ID from PR comments (for continuity)
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  per_page: 100
                });

                const autoTriggers = comments.filter(c => c.body.includes('Reviewer Feedback (Automatic Trigger)')).length;
                console.log(`Found ${autoTriggers} previous auto-triggers.`);

                if (autoTriggers >= MAX_RETRIES) {
                  console.log(`‚ö†Ô∏è Max retries (${MAX_RETRIES}) reached. Halting self-correction.`);
                  // Notify user about retry limit
                  const { data: issue } = await github.rest.issues.get({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber });
                  const stopBody = `üõë **Self-Correction Halted**\n\nRejected ${MAX_RETRIES} times. @${issue.user.login}, please review manually.`;
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, body: stopBody });
                  return;
                }

                // Session ID Search (PR Body & Comments)
                let sessionId = (context.payload.pull_request.body || '').match(/for task \[?(\d+)\]?/)?.[1];
                if (sessionId) {
                  console.log(`‚úÖ Session ID found in PR body: ${sessionId}`);
                } else {
                  for (const c of comments) {
                    const match = c.body.match(/<!-- JULES_SESSION_ID: (.+?) -->/) || c.body.match(/for task \[?(\d+)\]?/);
                    if (match) {
                      sessionId = match[1];
                      console.log(`‚úÖ Session ID found in comments: ${sessionId}`);
                      break;
                    }
                  }
                }

                if (!sessionId) {
                  console.log('‚ùå Self-correction failed: No Jules session ID found in PR body or comments.');
                  await github.rest.issues.createComment({
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
                    body: `‚ö†Ô∏è **Session Continuity Failed**\nCould not find a valid Jules session ID.`
                  });
                  return;
                }

                const apiKey = process.env.JULES_API_KEY;
                if (!apiKey) {
                  console.log('‚ùå Self-correction failed: JULES_API_KEY is not set.');
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber, body: '‚ö†Ô∏è **Self-Correction Failed**: `JULES_API_KEY` is missing.' });
                  return;
                }

                // Trigger Jules API
                try {
                  console.log(`Attempting to send feedback to Jules session ${sessionId} (Attempt ${autoTriggers + 1}/${MAX_RETRIES}).`);
                  const response = await fetch(`https://jules.googleapis.com/v1alpha/sessions/${sessionId}:sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Goog-Api-Key': apiKey },
                    body: JSON.stringify({ prompt: `Reviewer Feedback:\n\n${reviewText}\n\nPlease fix these issues.` })
                  });

                  if (!response.ok) {
                    throw new Error(`Jules API Error (${response.status}): ${await response.text()}`);
                  }

                  console.log('‚úÖ Feedback successfully sent to Jules.');
                  const confirmBody = `ü§ñ **Jules Triggered**\nFeedback sent for self-correction.\n*Session ID:* \`${sessionId}\`\n*Loop:* ${autoTriggers + 1}/${MAX_RETRIES}\n<!-- JULES_SESSION_ID: ${sessionId} -->\n<!-- Reviewer Feedback (Automatic Trigger) -->`;
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body: confirmBody });

                } catch (apiError) {
                  console.error(`‚ùå Jules API call failed: ${apiError.message}`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: issueNumber,
                    body: `‚ö†Ô∏è **Self-Correction API Failed**\nError: ${apiError.message}`
                  });
                }
              }
            }
      - name: Post Review (Beast Mode - Push)
        # üõ°Ô∏è Skip if actor is Jules (handled in PR mode) or if no issues found
        if: always() && github.event_name == 'push' && github.actor != 'google-labs-jules[bot]'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read.';
            }

            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ CLEAN' : '‚ùå ISSUES FOUND';
            
            // 1. Post Commit Comment (Always)
            if (reviewText.length > 10) {
               await github.rest.repos.createCommitComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: context.sha,
                  body: `## ü¶Å Beast Mode Code Inspector\n\n${reviewText}\n\n---\n\n**Status:** ${verdict}`
               });
            }

            // 2. Create Critical Issue (If REJECTED)
            if (!approved) {
              const commitSha = context.sha.substring(0, 7);
              const author = context.payload.pusher.name || context.actor;
              
              const title = `üö® Critical Issue Detected in Commit ${commitSha}`;
              const body = `### üõë Critical Issues Found during Push Analysis\n\n` +
                           `**Commit:** ${context.sha}\n` +
                           `**Author:** @${author}\n\n` +
                           `The **Reviewer Agent** detected critical problems in the recent push. Please address them immediately.\n\n` +
                           `---\n\n` +
                           `### üîé Review Findings\n\n${reviewText}\n\n` +
                           `> This issue was automatically created by HiveMind Beast Mode.`;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'critical', 'automated-review'],
                assignees: [context.actor]
              });
              
              console.log('üö® Critical Issue created successfully!');
            }
