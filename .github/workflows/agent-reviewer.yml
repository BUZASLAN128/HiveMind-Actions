# üîé HiveMind Reviewer Agent
# PR code review
#
# Trigger: pull_request opened (Created by Coder implementation)
# Task: Inspect Code, Check Rules, Security Analysis

name: 'üîé Agent: Reviewer (Gemini)'

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  # ü¶Å Beast Mode: Push Trigger
  push:
    branches:
      - 'main'
      - 'master'

concurrency:
  group: reviewer-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

jobs:
  review:
    name: 'üìù Code Review'
    runs-on: ubuntu-latest
    # Inspect PRs opened by the Coder or AI branches
    # Or PRs opened by the bot (github-actions[bot])
    # OR if it's a Push event (Beast Mode)
    if: >-
      github.event_name == 'push' ||
      contains(github.event.pull_request.head.ref, 'coder') ||
      contains(github.event.pull_request.head.ref, 'ai-') ||
      contains(github.event.pull_request.head.ref, 'feat/') ||
      contains(github.event.pull_request.head.ref, 'add-') ||
      github.event.pull_request.user.login == 'github-actions[bot]' ||
      github.event.pull_request.user.login == 'google-labs-code' ||
      github.event.pull_request.user.login == 'google-labs-jules'
    
    permissions:
      contents: write # Required for commit comments
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install google-genai

      - name: Get Diff (Smart Switch)
        id: diff
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "üìã PR Mode detected."
            git fetch origin ${{ github.event.pull_request.base.ref }}
            git diff origin/${{ github.event.pull_request.base.ref }}...HEAD > coder_changes.diff
          else
            echo "ü¶Å Beast Mode detected (Push)."
            # Get diff for Push: Current vs Previous commit
            if [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
               git diff HEAD^ HEAD > coder_changes.diff || git diff --cached > coder_changes.diff
            else
               git diff ${{ github.event.before }} ${{ github.event.after }} > coder_changes.diff || git diff HEAD^ HEAD > coder_changes.diff
            fi
          fi
          
          ls -lh coder_changes.diff

      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Notify Review Started (PR Only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Find associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;
            
            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';
              const idMatch = prBody.match(/<!-- SWARM_COMMENT_ID: (\d+) -->/);
              const commentId = idMatch ? idMatch[1] : null;

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | üîÑ **WORKING** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [/] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n> üîé Reviewer: PR #${context.payload.pull_request.number} is being analyzed...\n> üîó [View PR](${context.payload.pull_request.html_url})`;

              if (commentId) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: parseInt(commentId),
                    body: body
                  });
                  return; // Succeeded
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment ${commentId} not found or inaccessible, falling back to search.`);
                }
              }
              
              // Fallback to search
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50,
                sort: 'created',
                direction: 'desc'
              });
              const statusComment = comments.data.find(c => c.body.includes(marker));
              if (statusComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: statusComment.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: body
                });
              }
            }

      - name: Read Swarm Rules
        id: rules
        run: |
          if [ -f .github/swarm_rules.md ]; then
            content=$(cat .github/swarm_rules.md)
            echo "RULES<<EOF" >> $GITHUB_ENV
            echo "$content" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "RULES=No specific rules found." >> $GITHUB_ENV
          fi

      - name: Run Gemini Review
        id: review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # Run swarm_reviewer.py script
          # Script will read coder_changes.diff and create review_comment.md
          # It will also write approved=true/false to GITHUB_OUTPUT
          python .github/scripts/swarm_reviewer.py

      - name: Post Review (PR Mode)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            
            // Review sonucunu oku (Turkish comment restored)
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read or script failed.';
            }

            // Verify approval from script output (from steps/env)
            // Using steps.review.outputs.approved

            // swarm_reviewer.py GITHUB_OUTPUT'a approved yazƒ±yor, bunu steps objesinden alacaƒüƒ±z.
            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ APPROVED' : '‚ùå REJECTED';
            
            // PR'a review yaz
            if (reviewText.length > 10) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  event: approved ? 'APPROVE' : 'REQUEST_CHANGES',
                  body: `## üîé Gemini Code Review

                  ${reviewText}

                  ---

                  **Verdict:** ${verdict}

                  ${approved ? '> This PR is ready to merge.' : '> Please fix the issues mentioned above.'}`
                });
                
                // ü§ñ If rejected, post separate comment to trigger Jules
                if (!approved) {
                    await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.payload.pull_request.number,
                        body: `@google-labs-jules Please fix the issues mentioned in the review above. üîß`
                    });
                }
            }
            
            // Update associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;
            
            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';
              const idMatch = prBody.match(/<!-- SWARM_COMMENT_ID: (\d+) -->/);
              const commentId = idMatch ? idMatch[1] : null;

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | ‚úÖ **COMPLETED** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [x] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n---\n\n**Verdict:** ${verdict}\n\nüîó [PR #${context.payload.pull_request.number}](${context.payload.pull_request.html_url})\n\n${approved ? '> ‚úÖ **Ready to Merge!** Review passed.' : '> ‚ö†Ô∏è **Changes Needed.** Please address the issues.'}`;

              if (commentId) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: parseInt(commentId),
                    body: body
                  });
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment ${commentId} not found or inaccessible in Post Review, falling back to search.`);
                  // Fallback to search
                  const comments = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    per_page: 50,
                    sort: 'created',
                    direction: 'desc'
                  });
                  const statusComment = comments.data.find(c => c.body.includes(marker));
                  if (statusComment) {
                    await github.rest.issues.updateComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: statusComment.id,
                      body: body
                    });
                  } else {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: body
                    });
                  }
                }
              } else {
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  per_page: 50,
                  sort: 'created',
                  direction: 'desc'
                });
                const statusComment = comments.data.find(c => c.body.includes(marker));
                if (statusComment) {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: statusComment.id,
                    body: body
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body
                  });
                }
              }

              // üîÑ SELF-CORRECTION LOOP: Trigger Jules (Google Labs) via REST API
              if (!approved) {
                  const MAX_RETRIES = 5;
                  
                  // 1. Find existing session ID from comments
                  const comments = await github.rest.issues.listComments({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      per_page: 100
                  });
                  
                  const autoTriggers = comments.data.filter(c => c.body.includes('Reviewer Feedback (Automatic Trigger)')).length;
                  
                  // Find Session ID Pattern: <!-- JULES_SESSION_ID: 12345 -->
                  let limitReached = autoTriggers >= MAX_RETRIES;
                  let sessionId = null;
                  const sessionMatch = comments.data
                      .map(c => c.body.match(/<!-- JULES_SESSION_ID: (.+?) -->/))
                      .filter(m => m)[0];
                  
                  if (sessionMatch) {
                      sessionId = sessionMatch[1];
                      console.log('üîó Found existing Jules Session ID: ' + sessionId);
                  }

                  if (limitReached) {
                      console.log('‚ö†Ô∏è Max retries (' + MAX_RETRIES + ') reached. Stopping self-correction loop.');
                      const issueDetails = await github.rest.issues.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber
                      });
                      const issueAuthor = issueDetails.data.user.login;
                      
                      const stopBody = 'üõë **Self-Correction Stopped**\n\n' +
                          'Result: Rejected ' + MAX_RETRIES + ' times.\n' +
                          '@' + issueAuthor + ' please check manually.\n' +
                          '<!-- JULES_SESSION_ID: ' + (sessionId || 'none') + ' -->';

                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          body: stopBody
                      });
                      return;
                  }

                  console.log('üîÑ Triggering Jules API (Attempt ' + (autoTriggers + 1) + '/' + MAX_RETRIES + ')...');
                  
                  // Prepare Payload
                  const apiKey = process.env.JULES_API_KEY;
                  if (!apiKey) {
                      console.log('‚ùå JULES_API_KEY not found in environment. Skipping auto-fix.');
                      return;
                  }
                  
                  // Usage of fetch (Node 18+)
                  try {
                      let julesResp;
                      if (sessionId) {
                          // CONTINUE EXISTING SESSION
                          console.log('üì® Sending feedback to Session ' + sessionId + '...');
                          const response = await fetch('https://jules.googleapis.com/v1alpha/sessions/' + sessionId + ':sendMessage', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                                  'X-Goog-Api-Key': apiKey
                              },
                              body: JSON.stringify({ prompt: 'Reviewer Feedback:\n\n' + reviewText + '\n\nPlease fix these issues.' })
                          });
                          if (!response.ok) throw new Error('Jules API Error: ' + response.status);
                          julesResp = await response.json();
                          console.log('‚úÖ Feedback sent to Jules session.');
                      } else {
                          // CREATE NEW SESSION
                          console.log('üÜï Creating NEW Jules Session...');
                          const response = await fetch('https://jules.googleapis.com/v1alpha/sessions', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                                  'X-Goog-Api-Key': apiKey
                              },
                              body: JSON.stringify({
                                  prompt: 'Task: Fix issues in PR #' + context.payload.pull_request.number + '.\n\nReview Feedback:\n' + reviewText,
                                  sourceContext: {
                                      source: 'sources/github/' + context.repo.owner + '/' + context.repo.repo,
                                      githubRepoContext: {
                                          startingBranch: context.payload.pull_request.head.ref
                                      }
                                  },
                                  automationMode: 'AUTO_CREATE_PR'
                              })
                          });
                          if (!response.ok) throw new Error('Jules API Error: ' + response.status);
                          julesResp = await response.json();
                          sessionId = julesResp.id || julesResp.name.split('/').pop();
                          console.log('‚úÖ New Session Created: ' + sessionId);
                      }

                      // Post confirmation comment WITH Session ID for next run
                      const confirmBody = 'ü§ñ **Jules Triggered (REST API)**\n\n' +
                          'I have communicated the feedback to Jules.\n' +
                          '**Session ID:** `' + sessionId + '`\n\n' +
                          '> Loop: ' + (autoTriggers + 1) + '/' + MAX_RETRIES + '\n\n' +
                          '<!-- JULES_SESSION_ID: ' + sessionId + ' -->\n' +
                          '<!-- Reviewer Feedback (Automatic Trigger) -->';

                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          body: confirmBody
                      });
                      
                  } catch (apiError) {
                      console.error('‚ùå Jules REST API Failed:', apiError);
                  }
              }
            }
      - name: Post Review (Beast Mode - Push)
        if: github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read.';
            }

            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ CLEAN' : '‚ùå ISSUES FOUND';
            
            // 1. Post Commit Comment (Always)
            if (reviewText.length > 10) {
               await github.rest.repos.createCommitComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: context.sha,
                  body: `## ü¶Å Beast Mode Code Inspector\n\n${reviewText}\n\n---\n\n**Status:** ${verdict}`
               });
            }

            // 2. Create Critical Issue (If REJECTED)
            if (!approved) {
              const commitSha = context.sha.substring(0, 7);
              const author = context.payload.pusher.name || context.actor;
              
              const title = `üö® Critical Issue Detected in Commit ${commitSha}`;
              const body = `### üõë Critical Issues Found during Push Analysis\n\n` +
                           `**Commit:** ${context.sha}\n` +
                           `**Author:** @${author}\n\n` +
                           `The **Reviewer Agent** detected critical problems in the recent push. Please address them immediately.\n\n` +
                           `---\n\n` +
                           `### üîé Review Findings\n\n${reviewText}\n\n` +
                           `> This issue was automatically created by HiveMind Beast Mode.`;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'critical', 'automated-review'],
                assignees: [context.actor]
              });
              
              console.log('üö® Critical Issue created successfully!');
            }
