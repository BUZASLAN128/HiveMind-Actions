# üîé HiveMind Reviewer Agent
# PR code review
#
# Trigger: pull_request opened (Created by Coder implementation)
# Task: Inspect Code, Check Rules, Security Analysis

name: 'üîé Agent: Reviewer (Gemini)'

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  # ü¶Å Beast Mode: Push Trigger
  push:
    branches: ['**']

concurrency:
  group: reviewer-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

jobs:
  review:
    name: 'üìù Code Review'
    runs-on: ubuntu-latest
    # üîê Security: Only repo owner, buzaslan129, or bots can trigger this workflow
    if: |
      github.actor == github.repository_owner || 
      github.actor == 'buzaslan129' || 
      github.actor == 'dependabot[bot]' || 
      github.actor == 'github-actions[bot]'
    
    permissions:
      contents: write # Required for commit comments
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install google-genai

      - name: Get Diff (Smart Switch)
        id: diff
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "üìã PR Mode detected."
            git fetch origin ${{ github.event.pull_request.base.ref }}
            git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -- . ':(exclude)package-lock.json' ':(exclude)yarn.lock' ':(exclude)*.min.js' ':(exclude)*.map' ':(exclude)dist/' ':(exclude)build/' > coder_changes.diff
          else
            echo "ü¶Å Beast Mode detected (Push)."
            # Get diff for Push: Current vs Previous commit
            if [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
               git diff HEAD^ HEAD > coder_changes.diff || git diff --cached > coder_changes.diff
            else
               git diff ${{ github.event.before }} ${{ github.event.after }} -- . ':(exclude)package-lock.json' ':(exclude)dist/' > coder_changes.diff || git diff HEAD^ HEAD > coder_changes.diff
            fi
          fi
          
          ls -lh coder_changes.diff

      - name: Check Secrets
        id: check-secrets
        run: |
          if [ -n "${{ secrets.APP_ID }}" ]; then
            echo "has_app_id=true" >> $GITHUB_OUTPUT
          else
            echo "has_app_id=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate App Token (Optional - for custom branding)
        id: app-token
        if: steps.check-secrets.outputs.has_app_id == 'true'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      # Use App token if available, otherwise fallback to GITHUB_TOKEN
      - name: Set Token
        id: set-token
        run: |
          if [ -n "${{ steps.app-token.outputs.token }}" ]; then
            echo "token=${{ steps.app-token.outputs.token }}" >> $GITHUB_OUTPUT
            echo "Using custom GitHub App token"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "Using default GITHUB_TOKEN"
          fi

      - name: Notify Review Started (PR Only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.set-token.outputs.token }}
          script: |
            // Find associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;
            
            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | üîÑ **WORKING** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [/] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n> üîé Reviewer: PR #${context.payload.pull_request.number} is being analyzed...\n> üîó [View PR](${context.payload.pull_request.html_url})`;

              // Search for existing status comment by marker
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50,
                sort: 'created',
                direction: 'desc'
              });
              const statusComment = comments.data.find(c => c.body.includes(marker));
              
              if (statusComment) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: statusComment.id,
                    body: body
                  });
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment update failed, creating new one.`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body
                  });
                }
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: body
                });
              }
            }

      - name: Read Swarm Rules
        id: rules
        run: |
          if [ -f .github/swarm_rules.md ]; then
            content=$(cat .github/swarm_rules.md)
            echo "RULES<<EOF" >> $GITHUB_ENV
            echo "$content" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "RULES=No specific rules found." >> $GITHUB_ENV
          fi

      - name: Run Gemini Review
        id: review
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # Run swarm_reviewer.py script
          # Script will read coder_changes.diff and create review_comment.md
          # It will also write approved=true/false to GITHUB_OUTPUT
          python .github/scripts/swarm_reviewer.py

      - name: Apply Auto-Labels
        if: steps.review.outputs.labels != '' && github.event_name == 'pull_request'
        env:
          GH_TOKEN: ${{ steps.set-token.outputs.token }}
          LABELS: ${{ steps.review.outputs.labels }}
        run: |
          echo "üè∑Ô∏è Applying labels: $LABELS"
          gh pr edit ${{ github.event.pull_request.number }} --add-label "$LABELS"

      - name: Post Review (PR Mode)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
        with:
          github-token: ${{ steps.set-token.outputs.token }}
          script: |
            const fs = require('fs');
            
            // Read review result
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read or script failed.';
            }

            // Verify approval from script output (from steps/env)
            // Using steps.review.outputs.approved

            // swarm_reviewer.py GITHUB_OUTPUT'a approved yazƒ±yor, bunu steps objesinden alacaƒüƒ±z.
            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ APPROVED' : '‚ùå REJECTED';
            
            // PR'a review yaz
            if (reviewText.length > 10) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  event: approved ? 'APPROVE' : 'REQUEST_CHANGES',
                  body: `## üîé Gemini Code Review

                  ${reviewText}

                  ---

                  **Verdict:** ${verdict}

                  ${approved ? '> This PR is ready to merge.' : '> Please fix the issues mentioned above.'}`
                });
                // Note: Jules is triggered via REST API in the self-correction loop below
            }
            
            // Update associated issue
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/Fixes #(\d+)/) || prBody.match(/#(\d+)/);
            const issueNumber = issueMatch ? parseInt(issueMatch[1]) : null;
            
            if (issueNumber) {
              const marker = '<!-- SWARM_STATUS_REPORT -->';

              const table = [
                '| Agent | Status | Task |',
                '|-------|--------|------|',
                '| üîç Analyst | ‚úÖ **COMPLETED** | Issue Analysis |',
                '| ü§ñ Coder | ‚úÖ **COMPLETED** | Implementation |',
                '| üîé Reviewer | ‚úÖ **COMPLETED** | PR Review |'
              ].join('\n');

              const taskList = [
                '### üìù Task List',
                '- [x] Issue Analysis (Analyst)',
                '- [x] Code Changes (Coder)',
                '- [x] Create PR (Coder)',
                '- [x] PR Review (Reviewer)'
              ].join('\n');

              const header = `## üêù HiveMind Status Report ${marker}`;
              const body = `${header}\n\n${table}\n\n${taskList}\n\n---\n\n**Verdict:** ${verdict}\n\nüîó [PR #${context.payload.pull_request.number}](${context.payload.pull_request.html_url})\n\n${approved ? '> ‚úÖ **Ready to Merge!** Review passed.' : '> ‚ö†Ô∏è **Changes Needed.** Please address the issues.'}`;

              // Search for existing status comment by marker
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                per_page: 50,
                sort: 'created',
                direction: 'desc'
              });
              const statusComment = comments.data.find(c => c.body.includes(marker));
              
              if (statusComment) {
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: statusComment.id,
                    body: body
                  });
                } catch (e) {
                  console.log(`‚ö†Ô∏è Comment update failed, creating new one.`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body
                  });
                }
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: body
                });
              }

              // üîÑ SELF-CORRECTION LOOP: Trigger Jules (Google Labs) via REST API
              if (!approved) {
                  const MAX_RETRIES = 5;
                  
                  if (!reviewText || reviewText.trim().length < 10) {
                      console.log('‚ö†Ô∏è Review text is too short or empty. Skipping self-correction.');
                      return;
                  }

                  // 1. Find existing session ID from PR comments (not Issue)
                  const prNumber = context.payload.pull_request.number;
                  const comments = await github.rest.issues.listComments({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,  // Search PR comments for session ID
                      per_page: 100
                  });
                  
                  const autoTriggers = comments.data.filter(c => c.body.includes('Reviewer Feedback (Automatic Trigger)')).length;
                  
                  // Find Session ID - check multiple sources:
                  // 1. PR body (Jules writes "for task X" in description)
                  // 2. Comments: My format <!-- JULES_SESSION_ID: 123 -->
                  // 3. Comments: Jules' format "for task 123"
                  let limitReached = autoTriggers >= MAX_RETRIES;
                  let sessionId = null;

                  // FIRST: Check PR BODY for Jules task ID
                  const prBody = context.payload.pull_request.body || '';
                  console.log('üìã PR Body length: ' + prBody.length);
                  // Handle both plain text and markdown link: "for task 123" or "for task [123](url)"
                  const prBodyMatch = prBody.match(/for task \[?(\d+)\]?/);
                  if (prBodyMatch) {
                      sessionId = prBodyMatch[1];
                      console.log('üîó Found Session ID in PR BODY: ' + sessionId);
                  }

                  // If not in body, check comments
                  if (!sessionId) {
                      for (const c of comments.data) {
                          // Pattern 1: My hidden comment
                          const myMatch = c.body.match(/<!-- JULES_SESSION_ID: (.+?) -->/);
                          if (myMatch) {
                              sessionId = myMatch[1];
                              console.log('üîó Found Session ID (my format): ' + sessionId);
                              break;
                          }
                          // Pattern 2: Jules' native format in comment
                          const julesMatch = c.body.match(/for task \[?(\d+)\]?/);
                          if (julesMatch) {
                              sessionId = julesMatch[1];
                              console.log('üîó Found Session ID (Jules format in comment): ' + sessionId);
                              break;
                          }
                      }
                  }
                  
                  if (!sessionId) {
                      console.log('‚ùå No Session ID found in PR body or comments!');
                  } else {
                      console.log('‚úÖ Session ID to use: ' + sessionId);
                  }

                  if (limitReached) {
                      console.log('‚ö†Ô∏è Max retries (' + MAX_RETRIES + ') reached. Stopping self-correction loop.');
                      const issueDetails = await github.rest.issues.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber
                      });
                      const issueAuthor = issueDetails.data.user.login;
                      
                      const stopBody = 'üõë **Self-Correction Stopped**\n\n' +
                          'Result: Rejected ' + MAX_RETRIES + ' times.\n' +
                          '@' + issueAuthor + ' please check manually.\n' +
                          '<!-- JULES_SESSION_ID: ' + (sessionId || 'none') + ' -->';

                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          body: stopBody
                      });
                      return;
                  }

                  console.log('üîÑ Triggering Jules API (Attempt ' + (autoTriggers + 1) + '/' + MAX_RETRIES + ')...');
                  
                  // Prepare Payload
                  const apiKey = process.env.JULES_API_KEY;
                  if (!apiKey) {
                      console.log('‚ùå Error: JULES_API_KEY environment variable is not set. Cannot trigger self-correction.');
                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          body: '‚ö†Ô∏è **Self-Correction Failed**: `JULES_API_KEY` is missing.'
                      });
                      return;
                  }
                  
                  // Usage of fetch (Node 18+)
                  try {
                      let julesResp;
                      if (sessionId) {
                          // CONTINUE EXISTING SESSION
                          console.log('üì® Sending feedback to Session ' + sessionId + '...');
                          const response = await fetch('https://jules.googleapis.com/v1alpha/sessions/' + sessionId + ':sendMessage', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                                  'X-Goog-Api-Key': apiKey
                              },
                              body: JSON.stringify({ prompt: 'Reviewer Feedback:\n\n' + reviewText + '\n\nPlease fix these issues.' })
                          });

                          if (!response.ok) {
                              const errorText = await response.text();
                              throw new Error('Jules API Error (' + response.status + '): ' + errorText);
                          }

                          julesResp = await response.json();
                          console.log('‚úÖ Feedback sent to Jules session.');
                      } else {
                          // NO SESSION FOUND - STOP (no fallback)
                          console.log('‚ùå No Jules Session ID found! Cannot continue session.');
                          console.log('üìã Checked PR body and comments for patterns: for task X, JULES_SESSION_ID');
                          await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: prNumber,
                              body: '‚ö†Ô∏è **Session Continuity Failed**\n\nCould not find existing Jules session ID in PR body or comments.\n\n**Debug Info:**\n- PR Body checked: Yes\n- Comments checked: Yes\n- Patterns: `for task X`, `<!-- JULES_SESSION_ID: -->`\n\nPlease trigger Jules manually.'
                          });
                          return;
                      }

                      // Post confirmation comment WITH Session ID for next run
                      const confirmBody = 'ü§ñ **Jules Triggered (REST API)**\n\n' +
                          'I have communicated the feedback to Jules.\n' +
                          '**Session ID:** `' + sessionId + '`\n\n' +
                          '> Loop: ' + (autoTriggers + 1) + '/' + MAX_RETRIES + '\n\n' +
                          '<!-- JULES_SESSION_ID: ' + sessionId + ' -->\n' +
                          '<!-- Reviewer Feedback (Automatic Trigger) -->';

                      // Post to PR only (for session continuity)
                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: prNumber,
                          body: confirmBody
                      });
                      
                  } catch (apiError) {
                      console.error('‚ùå Jules REST API Failed:', apiError);
                      await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          body: '‚ö†Ô∏è **Self-Correction Failed** during API call.\n\nError: ' + apiError.message
                      });
                  }
              }
            }
      - name: Post Review (Beast Mode - Push)
        if: github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            let reviewText = '';
            try {
              reviewText = fs.readFileSync('review_comment.md', 'utf8');
            } catch (e) {
              reviewText = 'Review result could not be read.';
            }

            const approved = '${{ steps.review.outputs.approved }}' === 'true';
            const verdict = approved ? '‚úÖ CLEAN' : '‚ùå ISSUES FOUND';
            
            // 1. Post Commit Comment (Always)
            if (reviewText.length > 10) {
               await github.rest.repos.createCommitComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: context.sha,
                  body: `## ü¶Å Beast Mode Code Inspector\n\n${reviewText}\n\n---\n\n**Status:** ${verdict}`
               });
            }

            // 2. Create Critical Issue (If REJECTED)
            if (!approved) {
              const commitSha = context.sha.substring(0, 7);
              const author = context.payload.pusher.name || context.actor;
              
              const title = `üö® Critical Issue Detected in Commit ${commitSha}`;
              const body = `### üõë Critical Issues Found during Push Analysis\n\n` +
                           `**Commit:** ${context.sha}\n` +
                           `**Author:** @${author}\n\n` +
                           `The **Reviewer Agent** detected critical problems in the recent push. Please address them immediately.\n\n` +
                           `---\n\n` +
                           `### üîé Review Findings\n\n${reviewText}\n\n` +
                           `> This issue was automatically created by HiveMind Beast Mode.`;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'critical', 'automated-review'],
                assignees: [context.actor]
              });
              
              console.log('üö® Critical Issue created successfully!');
            }
